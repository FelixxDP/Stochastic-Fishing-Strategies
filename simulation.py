#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Aug  9 16:37:55 2022

@author: felixdubicki-piper
"""

import math as m
import numpy as np
import numpy.random as r
from numpy import pi
import matplotlib.pyplot as plt
from config import *

# Variables/functions to deal with
# TODO: L - use as default args only, not buried inside body,
#       make consistent across classes
# TODO: plot_params - make easily customiseable with lots of opt input args
# TODO: create_path - work out if more efficient to have multiple options for
#       create path, ie, all at once, then search, or update till found
# TODO: import default values explicitly

# Main Goals
# - make less reliant on old code, esp. config.py
# - have full replacement for old code
# - improve upon path making algorithm - need to find how to set tend
#   main issue is tend is unpredictable, but maybe can assume scaling
# - add proper animation capability


def startCoord(coord0):

    if coord0 == "random":
        coord = np.array([L*r.random(), L*r.random()])
    else:
        coord = np.array(coord0)

    return coord


def startAngle(angle0):
    if angle0 == "random":
        angle = 2*pi*r.random()
    else:
        angle = angle0

    return angle


def init_position(position0=None) -> np.array:
    if position0 is None:
        position0 = L*r.random([2, 1])
    else:
        position0 = np.array(position0).reshape([2, -1])
    return position0


def init_angle(angle0=None):
    if angle0 is None:
        angle = 2*pi*r.random()
    else:
        angle = angle0
    return angle

# ============ ===============================================================
#  HANDY MATH
# ============ ===============================================================


def pol2cart(angle: float, radius: float = 1) -> np.ndarray:
    x = np.array(np.cos(angle), ndmin=1)
    y = np.array(np.sin(angle), ndmin=1)
    return radius*np.array([x, y])


def cart2pol(vector: [list, np.ndarray]) -> tuple[float, float]:
    angle = np.arctan2(vector[1], vector[0])
    radius = np.sqrt(vector[0]**2 + vector[1]**2)
    return angle, radius


def t2i(t):
    # divide & round down for non-zero indicies ; add 1 to include t=0
    return int(np.floor(t/T) + 1)


def i2t(i):
    # minus 1 to exlcude t=0; multiply & round 1dp
    return round((i-1)*T, 1)

# ==================== =======================================================
#  MOVEMENT ALGORITHM
# ==================== =======================================================


class data:
    """2D Data object.

    Parameters
    ----------
    data : [list, np.ndarray], optional
        2D data. The default is [].
    NAME : str, optional
        Legend label. The default is 'Data'.
    COLOR : str, optional
        Plot color. The default is `calmblue`.

    Attributes
    ----------
    data : np.ndarray
        2D data.
    xtempdata : np.ndarray
        x data extracted from `data`.
    ytempdata : np.ndarray
        y data extracted from `data`.
    fig : mpl.figure.Figure
        Figure generated by `plot`.
    ax : mpl.axes.Axes
        Axes generated by `plot`.
    NAME : str
        Legend label.
    COLOR : str
        Plot color.

    Methods
    -------
    plot(tlim=1800, title=title, titlept=16, labelpt=12, tlabelpt=10)
        Generate new figure/axes, and plot `data`.
    add_plot(indexlim=None, scatter=scatter, newdata=[])
        Add a plot to existing axes.
    save_plot(filename)
        Save figure as pdf.
    """

    def __init__(self,
                 data: [list, np.ndarray] = [],  # /,
                 NAME: str = 'Data',
                 COLOR: str = calmblue,
                 **kwargs
                 ) -> None:
        """Initialise data object.

        Parameters
        ----------
        data : [list, np.ndarray], optional
            2D data. The default is [].
        NAME : str, optional
            Legend label. The default is 'Data'.
        COLOR : str, optional
            Plot color. The default is `calmblue`.

        Returns
        -------
        None
        """
        super().__init__(**kwargs)
        self.data = data
        self.NAME = NAME
        self.COLOR = COLOR

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, newdata):
        self._data = np.array(newdata).reshape([2, -1])
        self.xtempdata = self._data[0]
        self.ytempdata = self._data[1]

    def plot(self, ilim=None,
             title=title, titlept=16, labelpt=12, tlabelpt=10):
        self._init_plot()
        self.add_plot(ilim)
        self._set_labels(title, titlept, labelpt, tlabelpt)
        self._set_axes_params(tlabelpt=tlabelpt)
        plt.show()
        return self.fig, self.ax

    def add_plot(self, ilim=None, scatter=scatter, *,
                 newdata=None, newcolor=None, newname=None):
        if newdata is None:
            x = self.xtempdata[:ilim]
            y = self.ytempdata[:ilim]
        else:
            x = newdata[0][:ilim]
            y = newdata[1][:ilim]

        if newcolor:
            col = newcolor
        else:
            col = self.COLOR

        if newname:
            name = newname
        else:
            name = self.NAME

        if scatter:
            self.ax.scatter(x, y,  c=col, label=name, s=0.1,)
        else:
            self.ax.plot(x, y, c=col, label=name, linewidth=2, alpha=1)

    def _set_labels(self, title=title, titlept=16, labelpt=12, tlabelpt=10):
        plt.legend(loc='upper right', markerscale=10, fontsize=tlabelpt,
                   framealpha=0.95, handletextpad=0.2, handlelength=1.)

        self.ax.set_title(title, y=1.0, fontsize=titlept)
        self.ax.set_xlabel(r'$X$, metres', fontsize=labelpt)
        self.ax.set_ylabel(r'$Y$, metres', fontsize=labelpt)

    def _init_plot(self):
        self.fig = plt.figure(dpi=None, figsize=(5, 5))
        self.ax = self.fig.add_subplot(111)
        return self.fig, self.ax

    def _set_axes_params(self, width=0.4, axlim=L, tlabelpt=10):
        # limits & aspect
        self.ax.set_aspect('equal', 'box')
        self.ax.set(xlim=(0, axlim), ylim=(0, axlim))

        # spines
        for s in self.ax.spines:
            self.ax.spines[s].set_linewidth(width)

        # ticks
        self.ax.tick_params(labelsize=tlabelpt, direction='in', width=0.4)

    def save_plot(self, filename):
        self.fig.savefig('Figures/'+filename+'.pdf', format='pdf',
                         bbox_inches='tight', pad_inches=0)


class agent:
    """Agent object.

    A point particle with movement capabilities, restricted to a square box.
    The agent can move randomly, using a normal distribution or in straight
    lines. The normal distribution determines the change in angle at each
    timestep.

    Parameters
    ----------
    position0 : [list, np.array], optional
        Initial position, m. The default is [L/2, L/2].
    angle0 : float, optional
        Initial direction of movement, rad. The default is 0.
    SPEED : float, optional
        Constant speed, m/s. The default is 1.
    STD : float, optional
        Standard deviation of change in angle. The default is 0.2.
    LBOUND : float, optional
        Length of box in which movement is restricted to, m.
        The default is L.

    Attributes
    ----------
    position : [list, np.array]
        Position, m.
    angle : float
        Direction of movement, rad.
    direction : np.array
        Direction of movement, unit vector. Determined by angle.
    SPEED : float
        Constant speed, m/s.
    STD : float
        Standard deviation of change in angle.
    LBOUND : float
        Length of box in which movement is restricted to, m.

    Returns
    -------
    None
        DESCRIPTION.
    """

    def __init__(self,
                 position0: [list, np.array] = None,
                 angle0: float = None,  # /,
                 SPEED: float = 1,
                 STD: float = 0.2, *,
                 LBOUND: float = L,
                 **kwargs
                 ) -> None:
        """Initialise agent object.

        Parameters
        ----------
        position0 : [list, np.array], optional
            Initial position, m. The default is [L/2, L/2].
        angle0 : float, optional
            Initial direction of movement, rad. The default is 0.
        SPEED : float, optional
            Constant speed, m/s. The default is 1.
        STD : float, optional
            Standard deviation of change in angle. The default is 0.2.
        LBOUND : float, optional
            Length of box in which movement is restricted to, m.
            The default is L.

        Returns
        -------
        None
            DESCRIPTION.
        """
        super().__init__(**kwargs)
        self.position = init_position(position0)
        self.angle = init_angle(angle0)
        self.SPEED = SPEED
        self.STD = STD
        self.LBOUND = LBOUND

    @property
    def angle(self):
        return self._angle

    @angle.setter
    def angle(self, newangle):
        self._angle = newangle
        self.direction = pol2cart(self._angle)

    def update(self):
        if self.STD != 0:
            # TODO: need to figure out how std, T and SPEED
            #       relate to average radius of curvature

            # new direction (unit) vector
            self.angle += pi*r.normal(0, self.STD)
            # TODO: generate list of rand numbers first, then just index
            #       way faster with r.normal(0,1,SIZE) than with looping
            #       also quicker to CREATE new rands, than to SHUFFLE rands

        # new position
        self.position += self.SPEED*self.direction*T
        self._resolve_border()

    def _resolve_border(self):
        # conditions at lake border (ie prevent crossing)
        if self.position[0] <= 0 + (L-self.LBOUND)/2:
            self.position[0] = 2*(L-self.LBOUND)/2 - self.position[0]
            self.angle = pi-self.angle

        if self.position[1] <= 0 + (L-self.LBOUND)/2:
            self.position[1] = 2*(L-self.LBOUND)/2 - self.position[1]
            self.angle = -self.angle

        if self.position[0] >= (L+self.LBOUND)/2:
            self.position[0] = (2*(self.LBOUND+L)/2 - self.position[0])
            self.angle = pi-self.angle

        if self.position[1] >= (L+self.LBOUND)/2:
            self.position[1] = (2*(self.LBOUND+L)/2 - self.position[1])
            self.angle = -self.angle

    def __repr__(self):
        return "Agent with position "+str(self.position[:, 0])+"."


class path(agent, data):
    def __init__(self, tend=9000, *, startwalk=True, **kwargs):
        super().__init__(**kwargs)
        self.tend = tend
        if startwalk:
            self._createpath()

    @property
    def tend(self):
        return self._tend

    @tend.setter
    def tend(self, newtend):
        self._tend = newtend
        self.iend = t2i(self._tend)

    def _createpath(self):
        # TODO: incorporate optional ilim
        # initialise data
        self.data = self.position
        for i in range(self.iend):
            # update position (and time)
            self.update()
            # add to existing path
            self.data = np.concatenate((self.data, self.position), axis=1)
        return self.data

    def _createpath1(self):
        # TODO: incorporate optional ilim
        delta_angles = r.normal(0, self.STD, self.iend)
        angles = np.cumsum(delta_angles)
        directions = pol2cart(angles)
        displacements = self.SPEED*T*directions
        self.data = np.cumsum(displacements, axis=1)

    def __repr__(self):
        return "Path with name: "+str(self.NAME)+"."


class searchfield(path):
    # TODO: Incomplete code; will not work
    def __init__(self, wanderer,  # /,
                 sidelength=L, *,
                 startwalk=True, position0=[L/2, L/2], **kwargs):
        self.wanderer = wanderer
        super().__init__(position0=position0, startwalk=False, **kwargs)
        self.sidelength = sidelength
        if startwalk:
            self._createpath()
            self.wanderer._createpath()

    @property
    def wanderer(self):
        return self._wanderer

    @wanderer.setter
    def wanderer(self, newwanderer):
        if type(newwanderer) == path:
            self._wanderer = path
        else:
            # if newwanderer == kwds
            self._wanderer = path(**newwanderer)

    @property
    def tend(self):
        self._tend = super().tend
        return self._tend

    @tend.setter
    def tend(self, newtend):
        super(searchfield, self.__class__).tend.fset(self, newtend)
        self.wanderer.tend = self._tend

    @property
    def sidelength(self):
        return self._sidelength

    @sidelength.setter
    def sidelength(self, newsidelength):
        self._sidelength = newsidelength
        self.wanderer.LBOUND = self._sidelength

    def search(self):
        # TODO: generalise to any no. of agents
        sq_distances = np.sum((self.wanderer.data-self.data)**2,
                              axis=0)
        distances = np.sqrt(sq_distances)
        # XXX: will give error if none found
        found_indices = np.flatnonzero(distances <= fRad + bRad)
        print(found_indices)
        if found_indices.size == 0:
            return None
        else:
            self.ifound = found_indices[0]
            self.tfound = round(self.ifound*T, 1)
            return self.ifound

    def plot(self, ilim=None, **kwargs):
        self.fig, self.ax = super().plot(ilim=ilim, **kwargs)
        self.add_plot(ilim=ilim, **self._plotargs(self.wanderer))
        return self.fig, self.ax

    def _plotargs(self, path, **kwargs):
        plotargs = dict(newdata=path.data,
                        newcolor=path.COLOR,
                        newname=path.NAME,
                        **kwargs)
        return plotargs


def field_test(plot=False):
    fld = field([agent([[0], [L/2]]),
                 agent([[L], [L/2]], pi)])
    print(fld.search())
    if plot:
        fig, ax = fld.plot()
        return fld, fig, ax
    else:
        return fld


def plot_test(save=False):
    P = path(agent(STD=0.2, angle0=pi/3), 1800)
    fig, ax = P.plot()
    if save:
        P.save_plot('foo')
    return P, fig, ax

# ~~~~~~~~~~
#  OLD CODE
# ~~~~~~~~~~


def fish(col, fCoord, angle, t, speed, stnDev=fS, l=L, plot=plot):

    # generate random angle (flat distribution)
    if nrmDst == False and t > 0:
        if r.random() < p:  # probability of change in direction
            angle = 2*pi*r.random()

    # generate random angle (normal distribution)
    if nrmDst == True and t > 0:
        angle += pi*r.normal(0, stnDev)

    if t > 0:
        # new direction
        Dir = np.array([m.cos(angle), m.sin(angle)])  # unit vector

        # new coordinate
        fCoord += speed*Dir*T

        # conditions at lake border (ie prevent crossing)
        if fCoord[0] <= 0 + (L-l)/2:
            fCoord[0] = 2*(L-l)/2 - fCoord[0]
            angle = pi-angle

        if fCoord[1] <= 0 + (L-l)/2:
            fCoord[1] = 2*(L-l)/2 - fCoord[1]
            angle = -angle

        if fCoord[0] >= (L+l)/2:
            fCoord[0] = (2*(l+L)/2 - fCoord[0])
            angle = pi-angle

        if fCoord[1] >= (L+l)/2:
            fCoord[1] = (2*(l+L)/2 - fCoord[1])
            angle = -angle

    # scatter plot
    '''
    if plot:

        plt.xlim(-1,L)
        plt.ylim(-1,L)

        plt.xlabel('x, $metres$')
        plt.ylabel('y, $metres$')

        plt.axes().set_aspect('equal')

        if nrmDst:
            plt.title(f'Norm Dist,  $\sigma_f$ = {fS},  $\sigma_b$ = {bS}')
        else:
            plt.title(f'Flat Dist, P = {p}')
        plt.scatter(fCoord[0],fCoord[1], s=0.1, color=col)
    '''

    return fCoord, angle

# ================= ==========================================================
#  FISHING MODEL 1
# ================= ==========================================================


def fishing():
    """Go fishing.

    Here, the boat uses the same algorithm as the fish, so changing bS will
    achieve different levels of randomness, the start angle and coords can
    also be changed.

    For linear motion set bS = 0.

    This function generates a new boat boat path each time, so be aware of how
    long it takes to run.

    Returns
    -------
    results : TYPE
        DESCRIPTION.
    """
    results = []

    for n in range(N):

        # start time
        t = 0

        # compute starting values
        fState = ['blue', startCoord(fCoord0), startAngle(fAngle0)]
        bState = ['red', startCoord(bCoord0), startAngle(bAngle0)]

        # boat to fish vector
        displacement = fState[1] - bState[1]
        # boat to fish distance
        distance = m.sqrt(displacement[0]**2 + displacement[1]**2)

        # Run simulation
        while distance > (fRad + bRad):

            # boat to fish vector
            displacement = fState[1] - bState[1]
            # boat to fish distance
            distance = m.sqrt(displacement[0]**2 + displacement[1]**2)

            # fish movement
            fState[1], fState[2] = fish(fState[0], fState[1], fState[2], t, f)
            # boat movement
            bState[1], bState[2] = fish(bState[0], bState[1], bState[2], t, b,
                                        bS, bL)

            '''
            # animated plot
            if animated == True and plot == True:
                plt.show() # show each step (ie animated)
                time.sleep( T*ps**-1 ) # real time delay

            t += T # increase time
            t = round(t,1)
            '''

        results.append(t)

        '''
        plt.legend()
        plt.show()
        '''

        if n % 100 == 0:
            print(int(100*n/N), "%", end=", ")

    return results

# ================= ========== ===============================================
#  FISHING MODEL 2   [linear]
# ================= ========== ===============================================


def fishingOptimised(boatPath: list[np.ndarray],
                     label1: str = flabel,
                     label2: str = blabel,
                     title: str = title) -> list[float]:
    """Go fishing, but faster.

    This function is more efficient as it creates a predefined boat
    trajectory, rather than recalculating it for every iteration N.

    Good for linear motion (bS=0), possibly less accurate for random (bS>0).


    Parameters
    ----------
    boatPath : list[np.ndarray]
        List of coordinates corresponding to each timestep.
    label1 : str, optional
        Legend label for the fish. The default is `flabel`.
    label2 : str, optional
        Legend label for the boat. The default is `blabel`.
    title : str, optional
        Axes title. The default is `title`.

    Returns
    -------
    results: list[float]
        List containg resulting search time for each simulation.

    """
    results = []

    for n in range(N):

        # start time
        t = 0

        # initialise record of fish and boat paths (for plotting)
        fishAndBoatPath = [[], []]

        # compute starting values
        fState = ['blue', startCoord(fCoord0), startAngle(fAngle0)]

        # inital boat to fish vector
        displacement = fState[1] - boatPath[0]
        # initial boat to fish distance
        distance = m.sqrt(displacement[0]**2 + displacement[1]**2)

        # Run simulation
        for i in range(len(boatPath)):

            # new boat to fish vector
            displacement = fState[1] - boatPath[i]
            # new boat to fish distance
            distance = m.sqrt(displacement[0]**2 + displacement[1]**2)

            # fish movement
            fState[1], fState[2] = fish(fState[0], fState[1], fState[2], t, f)

            if plot:
                # save current coord. of fish and boat
                fishAndBoatPath[0].append(np.array(list(fState[1])))
                fishAndBoatPath[1].append(boatPath[i])

            # animated plot
            if animated:
                plt.xlim(-1, L)
                plt.ylim(-1, L)

                plt.xlabel('x, $metres$')
                plt.ylabel('y, $metres$')

                plt.axes().set_aspect('equal')

                plt.title(title)

                if scatter:
                    plt.scatter(fState[1][0], fState[1][1], s=0.1, color='b')
                    plt.scatter(boatPath[i][0], boatPath[i]
                                [1], s=0.1, color='r')
                else:
                    fishX = [coord[0] for coord in fishAndBoatPath[0]]
                    fishY = [coord[1] for coord in fishAndBoatPath[0]]

                    boatX = [coord[0] for coord in fishAndBoatPath[1]]
                    boatY = [coord[1] for coord in fishAndBoatPath[1]]

                    plt.plot(fishX, fishY, c='b',
                             label='$\sigma_{fish}$ = '+str(fS))
                    plt.plot(boatX, boatY, c='r',
                             label='$\sigma_{boat}$ = '+str(bS))
                    # plt.plot(fishAndBoatPath[0][i][0],
                    #          fishAndBoatPath[0][i][1], color='b')
                    # plt.plot(fishAndBoatPath[1][i][0],
                    #          fishAndBoatPath[1][i][1], color='r')

                plt.show()  # show each step (ie animated)
                # time.sleep( T*ps**-1 ) # real time delay

            if distance <= (fRad + bRad):
                break

            t += T  # increase time
            t = round(t, 1)

        results.append(t)

        # plot fish and boat paths
        if plot:
            fishX = [coord[0] for coord in fishAndBoatPath[0]]
            fishY = [coord[1] for coord in fishAndBoatPath[0]]

            boatX = [coord[0] for coord in fishAndBoatPath[1]]
            boatY = [coord[1] for coord in fishAndBoatPath[1]]

            fig = plt.figure(dpi=300, figsize=(2.5, 2.5))
            ax = fig.add_subplot(111)

            if scatter:
                ax.scatter(fishX, fishY, s=0.1, c='b',
                           label='$\sigma_{fish}$ = '+str(fS))
                ax.scatter(boatX, boatY, s=0.1, c='r',
                           label='$\sigma_{boat}$ = '+str(bS))

            else:
                ax.plot(fishX, fishY, c='b',
                        label='$\sigma_{fish}$ = '+str(fS))
                ax.plot(boatX, boatY, c='r',
                        label='$\sigma_{boat}$ = '+str(bS))

            ax.set_aspect('equal', 'box')
            ax.set(xlim=(-1, L), ylim=(-1, L))

            # plt.legend(bbox_to_anchor=(0.01, 0.905, 0.98, 0.1),
            #            loc='lower left', ncol=2, mode="expand",
            #            borderaxespad=0., markerscale=10, framealpha=1)

            plt.legend(loc='upper right', markerscale=10, fontsize=8,
                       framealpha=0.95, handletextpad=0.2, handlelength=1.)

            ax.set_xlabel('X, $metres$', fontsize=8)
            ax.set_ylabel('Y, $metres$', fontsize=8)

            ax.tick_params(axis='x', which='major', labelsize=8)
            ax.tick_params(axis='y', which='major', labelsize=8,
                           labelrotation=90)

            ax.set_title(title, y=1.0)

            plt.show()

        if n > 0 and n % 100 == 0:
            print(int(100*n/N), "%", end=", ")

    return results


def plotBoat(boatPath, tLim=1800, col='r', title=title, label='Boat'):
    """Plot a precreated boat path.

    Parameters
    ----------
    boatPath : TYPE
        DESCRIPTION.
    tLim : TYPE, optional
        DESCRIPTION. The default is 1800.
    col : TYPE, optional
        DESCRIPTION. The default is 'r'.
    title : TYPE, optional
        DESCRIPTION. The default is title.
    label : TYPE, optional
        DESCRIPTION. The default is 'Boat'.

    Returns
    -------
    None.
    """
    indexLim = round(tLim/T)

    boatX = [coord[0] for coord in boatPath]
    boatY = [coord[1] for coord in boatPath]

    fig = plt.figure(dpi=300, figsize=(2.5, 2.5))
    ax = fig.add_subplot(111)

    if scatter:
        ax.scatter(boatX[:indexLim], boatY[:indexLim],
                   s=0.1, c=col, label=label)
    else:
        ax.plot(boatX[:indexLim], boatY[:indexLim], c=col, label=label)

    ax.set_aspect('equal', 'box')
    ax.set(xlim=(0, L), ylim=(0, L))

    plt.legend(loc='upper right', markerscale=10, fontsize=8, framealpha=0.95,
               handletextpad=0.2, handlelength=1.)

    ax.set_xlabel('X, $metres$', fontsize=8)
    ax.set_ylabel('Y, $metres$', fontsize=8)

    ax.tick_params(axis='x', which='major', labelsize=8)
    ax.tick_params(axis='y', which='major', labelsize=8, labelrotation=90)

    ax.set_title(title, y=1.0)

    plt.show()


def createBoatPath(coord0=bCoord0, angle0=bAngle0, stnDev=bS, speed=b):
    """Create a boat path.

    Parameters
    ----------
    coord0 : TYPE, optional
        DESCRIPTION. The default is bCoord0.
    angle0 : TYPE, optional
        DESCRIPTION. The default is bAngle0.
    stnDev : TYPE, optional
        DESCRIPTION. The default is bS.
    speed : TYPE, optional
        DESCRIPTION. The default is b.

    Returns
    -------
    boatPath : TYPE
        DESCRIPTION.
    """
    # initialise
    t = 0
    bState = ['red', startCoord(coord0), startAngle(angle0)]
    boatPath = []

    # set t upper bound at least 10x expected fish catching time
    while t < 500000:

        # new boat coord
        bState[1], bState[2] = fish(bState[0], bState[1], bState[2],
                                    t, speed, stnDev, l=bL, plot=False)
        boatPath.append(np.array(list(bState[1])))

        t += T  # increase time
        t = round(t, 1)

    return boatPath


def circularMotion(constRad=True, RATIO=0.95, radTimePeriod=450, speed=b,
                   animated=False):

    # initialise
    t = 0
    bCoord = startCoord(bCoord0)
    boatPath = []
    radRateChange = 2*(pi)/(2*radTimePeriod)
    invRATIO = 1-RATIO
    jumpStep = pi/(2*radRateChange)

    # define start/max radius
    RAD = m.sqrt((bCoord[0]-L/2)**2+(bCoord[1]-L/2)**2)

    # set t upper bound at least 10x expected fish catching time
    while t < 500000:

        if constRad:
            bCoord = [RAD*m.cos(t*speed/RAD) + L/2,
                      RAD*m.sin(t*speed/RAD) + L/2]
        else:
            # determine current radius
            rad = RAD*(RATIO*m.cos(radRateChange*t)**2 + 1-RATIO)
            # determine number of angle steps
            nStep = (1+t//jumpStep)//2

            # determine new angle
            angleFunc = (speed/RAD)*1/(radRateChange*m.sqrt(invRATIO)) * \
                m.atan(m.sqrt(invRATIO)*m.tan(radRateChange*t))

            # angle step, as function 'resets' periodcally,
            # causing jumps in the trajectory
            angleFunc += nStep*(speed/RAD)*1 / \
                (radRateChange*m.sqrt(invRATIO))*pi

            # new boat coord
            bCoord = [rad*m.cos(angleFunc) + L/2, rad*m.sin(angleFunc) + L/2]

        boatPath.append(bCoord)

        if animated:

            plt.xlim(-1, L)
            plt.ylim(-1, L)

            plt.xlabel('x, $metres$')
            plt.ylabel('y, $metres$')

            plt.axes().set_aspect('equal')

            plt.title('Spiral')

            plt.scatter(bCoord[0], bCoord[1], s=0.1, color='red')
            # time.sleep( T*ps**-1 ) # real time delay

            plt.show()

        t += T  # increase time
        t = round(t, 1)

    return boatPath
